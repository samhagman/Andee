#!/bin/bash
# sync-from-artifacts.sh - One-time sync from existing artifacts to MENU.JSON
#
# Scans artifact files and ensures MENU.JSON has all vocabularies that are
# currently in use. Vocabularies can be:
# - Enumerated: Known set of values (tags, cuisine, neighborhood)
# - Custom: Free-form values per artifact (address, phone, website)
# - Boolean: true/false fields (visited, favorite, to_try)
#
# Usage: sync-from-artifacts.sh [artifact_type] [senderId]
# Examples:
#   sync-from-artifacts.sh                    # Sync ALL types in shared
#   sync-from-artifacts.sh restaurants        # Sync just restaurants
#   sync-from-artifacts.sh restaurants 12345  # Sync private restaurants

set -e

ARTIFACT_TYPE=${1:-""}
SENDER_ID=${2:-""}

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Determine paths
if [ -n "$SENDER_ID" ]; then
  LISTS_DIR="/home/claude/private/${SENDER_ID}/lists"
else
  LISTS_DIR="/home/claude/shared/lists"
fi
MENU_FILE="${LISTS_DIR}/MENU.JSON"

# Check if yq is available
if ! command -v yq &> /dev/null; then
  echo "ERROR: yq is required but not installed"
  exit 1
fi

# Fields that are always in schema.required and should be skipped
REQUIRED_FIELDS="uuid type title created_at created_by status scope"

# Fields that are system/metadata and should NOT become vocabularies
# These are generated by the system, not user-defined metadata
SKIP_FIELDS="media_paths"

# Fields where we should NOT enumerate values (just note the vocabulary exists)
# These have custom/unique values per artifact rather than a known set
CUSTOM_VALUE_FIELDS="address phone website trip_id confirmation_code flight_number cost travelers route travel_date notes hours"

# Function to check if a field is in required list
is_required_field() {
  local field=$1
  for req in $REQUIRED_FIELDS; do
    if [ "$field" = "$req" ]; then
      return 0
    fi
  done
  return 1
}

# Function to check if field should be skipped entirely
is_skip_field() {
  local field=$1
  for skip in $SKIP_FIELDS; do
    if [ "$field" = "$skip" ]; then
      return 0
    fi
  done
  return 1
}

# Function to check if field has custom values (don't enumerate)
is_custom_value_field() {
  local field=$1
  for custom in $CUSTOM_VALUE_FIELDS; do
    if [ "$field" = "$custom" ]; then
      return 0
    fi
  done
  return 1
}

# Generate a smart description based on field name
get_field_description() {
  local field=$1
  case "$field" in
    visited) echo "Whether this place has been visited (true/false)" ;;
    favorite) echo "Marked as a favorite (true/false)" ;;
    to_try) echo "On the list to try (true/false)" ;;
    neighborhood) echo "Area or district where the place is located" ;;
    city) echo "City where the place is located" ;;
    address) echo "Street address (custom per artifact)" ;;
    phone) echo "Phone number (custom per artifact)" ;;
    website) echo "Website URL (custom per artifact)" ;;
    source) echo "Where this was discovered (Instagram, blog, recommendation)" ;;
    specialties) echo "What this place is known for" ;;
    cuisine) echo "Type of cuisine or food style" ;;
    hours) echo "Operating hours" ;;
    favorites) echo "Favorite items or dishes at this place" ;;
    prep_time) echo "Preparation time for the recipe" ;;
    cook_time) echo "Cooking time for the recipe" ;;
    equipment) echo "Kitchen equipment needed" ;;
    airline) echo "Airline carrier" ;;
    trip_id) echo "Trip identifier (custom per artifact)" ;;
    confirmation_code) echo "Booking confirmation code (custom per artifact)" ;;
    travel_date) echo "Date of travel (custom per artifact)" ;;
    route) echo "Travel route (e.g., BOS-SFO)" ;;
    flight_number) echo "Flight number (custom per artifact)" ;;
    travelers) echo "People traveling (custom per artifact)" ;;
    cost) echo "Total cost (custom per artifact)" ;;
    notes) echo "Additional notes or comments (custom per artifact)" ;;
    category) echo "Category classification" ;;
    *) echo "Synced from existing artifacts" ;;
  esac
}

# Function to sync a single artifact type
sync_artifact_type() {
  local type=$1
  local type_dir="${LISTS_DIR}/${type}"

  if [ ! -d "$type_dir" ]; then
    echo "SKIP: Directory not found: ${type_dir}"
    return
  fi

  echo ""
  echo "=== Syncing: ${type} ==="
  echo "Directory: ${type_dir}"

  local file_count=0
  local vocab_added=0
  local value_added=0

  # Process each markdown file
  for artifact_file in "${type_dir}"/*.md; do
    [ -f "$artifact_file" ] || continue
    file_count=$((file_count + 1))

    # Extract frontmatter fields using yq
    # yq can read YAML frontmatter from markdown files
    fields=$(yq -f extract 'keys | .[]' "$artifact_file" 2>/dev/null || echo "")

    if [ -z "$fields" ]; then
      continue
    fi

    # Process each field
    while IFS= read -r field; do
      [ -z "$field" ] && continue

      # Skip required fields
      if is_required_field "$field"; then
        continue
      fi

      # Skip system/metadata fields entirely
      if is_skip_field "$field"; then
        continue
      fi

      # Get the value for this field
      value=$(yq -f extract ".${field}" "$artifact_file" 2>/dev/null || echo "")

      # Skip empty values
      [ -z "$value" ] || [ "$value" = "null" ] && continue

      # Check if vocabulary exists, add if not
      if ! jq -e ".artifact_types.${type}.vocabularies.${field}" "$MENU_FILE" > /dev/null 2>&1; then
        description=$(get_field_description "$field")
        echo "  + Adding vocabulary: ${field}"
        if [ -n "$SENDER_ID" ]; then
          "${SCRIPT_DIR}/add-vocabulary.sh" "$type" "$field" "$description" "$SENDER_ID" > /dev/null
        else
          "${SCRIPT_DIR}/add-vocabulary.sh" "$type" "$field" "$description" > /dev/null
        fi
        vocab_added=$((vocab_added + 1))
      fi

      # Skip value enumeration for custom fields (address, phone, etc.)
      if is_custom_value_field "$field"; then
        continue
      fi

      # Try to extract as array first - if it returns content, it's an array
      # This avoids yq 'type' parsing issues with special characters like @
      array_values=$(yq -f extract ".${field}[]" "$artifact_file" 2>/dev/null || echo "")

      if [ -n "$array_values" ]; then
        # It's an array - iterate through values
        while IFS= read -r arr_val; do
          [ -z "$arr_val" ] && continue

          # Check if value exists in MENU.JSON
          if ! jq -e ".artifact_types.${type}.vocabularies.${field}.values.\"${arr_val}\"" "$MENU_FILE" > /dev/null 2>&1; then
            echo "    + Adding value: ${field}=${arr_val}"
            if [ -n "$SENDER_ID" ]; then
              "${SCRIPT_DIR}/update-menu-vocab.sh" "$type" "$field" "$arr_val" "Synced from existing artifacts" "$SENDER_ID" > /dev/null
            else
              "${SCRIPT_DIR}/update-menu-vocab.sh" "$type" "$field" "$arr_val" "Synced from existing artifacts" > /dev/null
            fi
            value_added=$((value_added + 1))
          fi
        done <<< "$array_values"
      else
        # Single value - check if it exists
        # Skip booleans and numbers for value tracking (we just track the vocabulary)
        case "$value" in
          true|false|[0-9]*) continue ;;
        esac

        # Skip multiline values (like hours objects) - too complex for vocabulary enumeration
        # Count lines - if more than 1, it's multiline
        line_count=$(printf '%s\n' "$value" | wc -l | tr -d ' ')
        if [ "$line_count" -gt 1 ]; then
          continue
        fi

        if ! jq -e ".artifact_types.${type}.vocabularies.${field}.values.\"${value}\"" "$MENU_FILE" > /dev/null 2>&1; then
          echo "    + Adding value: ${field}=${value}"
          if [ -n "$SENDER_ID" ]; then
            "${SCRIPT_DIR}/update-menu-vocab.sh" "$type" "$field" "$value" "Synced from existing artifacts" "$SENDER_ID" > /dev/null
          else
            "${SCRIPT_DIR}/update-menu-vocab.sh" "$type" "$field" "$value" "Synced from existing artifacts" > /dev/null
          fi
          value_added=$((value_added + 1))
        fi
      fi

    done <<< "$fields"
  done

  echo "  Files scanned: ${file_count}"
  echo "  Vocabularies added: ${vocab_added}"
  echo "  Values added: ${value_added}"
}

# Ensure MENU.JSON exists
if [ ! -f "$MENU_FILE" ]; then
  echo "Creating MENU.JSON at ${MENU_FILE}"
  TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  mkdir -p "$LISTS_DIR"
  cat > "$MENU_FILE" << MENUJSON
{
  "description": "Lists and artifacts",
  "created_at": "${TIMESTAMP}",
  "last_updated": "${TIMESTAMP}",
  "artifact_types": {}
}
MENUJSON
fi

echo "MENU.JSON: ${MENU_FILE}"
echo "Starting sync..."

if [ -n "$ARTIFACT_TYPE" ]; then
  # Sync specific type
  sync_artifact_type "$ARTIFACT_TYPE"
else
  # Sync all types found in MENU.JSON
  types=$(jq -r '.artifact_types | keys[]' "$MENU_FILE" 2>/dev/null || echo "")

  if [ -z "$types" ]; then
    # No types in MENU.JSON, scan directories
    echo "No types in MENU.JSON, scanning directories..."
    for dir in "${LISTS_DIR}"/*/; do
      [ -d "$dir" ] || continue
      type=$(basename "$dir")
      [ "$type" = "MENU.JSON" ] && continue
      sync_artifact_type "$type"
    done
  else
    while IFS= read -r type; do
      [ -z "$type" ] && continue
      sync_artifact_type "$type"
    done <<< "$types"
  fi
fi

echo ""
echo "=== Sync complete ==="
echo "MENU.JSON updated at: ${MENU_FILE}"
# Cache bust Wed Jan 21 22:28:03 PST 2026
